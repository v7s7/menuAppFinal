rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ==================== HELPER FUNCTIONS ====================

    function isSignedIn() {
      return request.auth != null;
    }

    function getUserRole(merchantId, branchId) {
      return isSignedIn() &&
        exists(/databases/$(database)/documents/merchants/$(merchantId)/branches/$(branchId)/roles/$(request.auth.uid))
          ? get(/databases/$(database)/documents/merchants/$(merchantId)/branches/$(branchId)/roles/$(request.auth.uid)).data.role
          : null;
    }

    function isAdmin(merchantId, branchId) {
      return getUserRole(merchantId, branchId) == 'admin';
    }

    function isStaff(merchantId, branchId) {
      return getUserRole(merchantId, branchId) in ['admin', 'staff'];
    }

    // Legacy compatibility
    function isOwner(merchantId, branchId) {
      return isAdmin(merchantId, branchId);
    }

    // Service account check (for Cloudflare Worker)
    function isServiceAccount() {
      return request.auth != null &&
        request.auth.token.email != null &&
        request.auth.token.email.matches('.*@.*\\.iam\\.gserviceaccount\\.com$');
    }

    // Get checkout fields config for validation
    function getCheckoutConfig(merchantId, branchId) {
      let configPath = /databases/$(database)/documents/merchants/$(merchantId)/branches/$(branchId)/config/checkoutFields;
      return exists(configPath) ? get(configPath).data : {
        'phoneRequired': true,
        'plateNumberRequired': true,
        'tableRequired': false,
        'addressRequired': false
      };
    }

    // Validate required checkout fields based on fulfillmentType
    function hasRequiredCheckoutFields(merchantId, branchId, orderData) {
      // fulfillmentType is REQUIRED for all new orders
      let hasFulfillmentType = orderData.keys().hasAny(['fulfillmentType']) &&
        orderData.fulfillmentType is string &&
        orderData.fulfillmentType in ['car_pickup', 'delivery', 'dine_in'];

      // Validate type-specific required fields
      let hasTypeSpecificFields =
        // Car pickup requires customerCarPlate
        (orderData.fulfillmentType == 'car_pickup' &&
         orderData.keys().hasAny(['customerCarPlate']) &&
         orderData.customerCarPlate is string &&
         orderData.customerCarPlate.size() > 0) ||
        // Delivery requires customerAddress with required fields
        (orderData.fulfillmentType == 'delivery' &&
         orderData.keys().hasAny(['customerAddress']) &&
         orderData.customerAddress is map &&
         orderData.customerAddress.keys().hasAny(['home', 'road', 'block', 'city']) &&
         orderData.customerAddress.home is string && orderData.customerAddress.home.size() > 0 &&
         orderData.customerAddress.road is string && orderData.customerAddress.road.size() > 0 &&
         orderData.customerAddress.block is string && orderData.customerAddress.block.size() > 0 &&
         orderData.customerAddress.city is string && orderData.customerAddress.city.size() > 0) ||
        // Dine-in requires table
        (orderData.fulfillmentType == 'dine_in' &&
         orderData.keys().hasAny(['table']) &&
         orderData.table is string &&
         orderData.table.size() > 0);

      return hasFulfillmentType && hasTypeSpecificFields;
    }

    // ==================== GLOBAL COLLECTIONS ====================

    // Slugs: Public read, no direct writes (only via Cloud Functions or manual admin)
    match /slugs/{slug} {
      allow read: if true;
      allow create, update: if isSignedIn();  // Allow for branding_admin_page.dart
      allow delete: if false;  // Prevent accidental deletion
    }

    // ==================== MERCHANT HIERARCHY ====================

    match /merchants/{merchantId} {
      // Merchant doc itself
      allow read: if true;
      allow write: if isOwner(merchantId, 'any');  // At least one branch owner

      match /branches/{branchId} {
        // Branch doc
        allow read: if true;
        allow write: if isStaff(merchantId, branchId);

        // -------------------- MENU ITEMS --------------------
        match /menuItems/{itemId} {
          // PUBLIC READ: Anyone can see menu items (app filters by isActive on client side)
          allow read: if true;

          // ADMIN WRITE: Only admins can create/update/delete menu items
          allow create: if isAdmin(merchantId, branchId) &&
            request.resource.data.merchantId == merchantId &&
            request.resource.data.branchId == branchId &&
            request.resource.data.isActive is bool &&
            request.resource.data.price is number &&
            request.resource.data.price >= 0 &&
            request.resource.data.name is string &&
            request.resource.data.name.size() > 0;

          allow update: if isAdmin(merchantId, branchId);
          allow delete: if isAdmin(merchantId, branchId);
        }

        // -------------------- CATEGORIES --------------------
        match /categories/{categoryId} {
          // PUBLIC READ: Anyone can see categories
          allow read: if true;

          // ADMIN WRITE: Only admins can create/update/delete categories
          allow create, update, delete: if isAdmin(merchantId, branchId);
        }

        // -------------------- ORDERS --------------------
        match /orders/{orderId} {
          // CREATE: Any signed-in user can place order
          // Backwards compatible: notifications is OPTIONAL.
          // If notifications exists, it must be correctly initialized.
          // Config-based validation: Required checkout fields based on merchant config
          allow create: if isSignedIn() &&
            request.resource.data.userId == request.auth.uid &&
            request.resource.data.status == 'pending' &&
            request.resource.data.merchantId == merchantId &&
            request.resource.data.branchId == branchId &&
            request.resource.data.items is list &&
            request.resource.data.items.size() > 0 &&
            request.resource.data.items.size() <= 50 &&
            request.resource.data.subtotal is number &&
            request.resource.data.subtotal >= 0 &&
            request.resource.data.subtotal <= 1000 &&
            (
              !request.resource.data.keys().hasAny(['notifications']) ||
              (
                request.resource.data.notifications is map &&
                request.resource.data.notifications.keys().hasOnly(['waNewSent', 'waCancelSent']) &&
                request.resource.data.notifications.waNewSent == false &&
                request.resource.data.notifications.waCancelSent == false
              )
            ) &&
            // NEW: Validate required checkout fields based on config
            hasRequiredCheckoutFields(merchantId, branchId, request.resource.data);

          // READ: Own orders or staff
          allow read: if isSignedIn() &&
            (resource.data.userId == request.auth.uid ||
             isStaff(merchantId, branchId));

          // UPDATE: Service account (Cloudflare Worker) can ONLY update notification fields
          allow update: if isServiceAccount() &&
            // Only notifications can change at the top-level
            request.resource.data.diff(resource.data).affectedKeys().hasOnly(['notifications']) &&
            // Notifications field must be a map
            request.resource.data.notifications is map &&
            // Only valid notification fields allowed
            request.resource.data.notifications.keys().hasOnly([
              'waNewSent', 'waCancelSent',
              'waNewSentAt', 'waNewSid',
              'waCancelSentAt', 'waCancelSid'
            ]);

          // UPDATE: Staff (including admin) can ONLY update order status workflow fields
          // STRICT VALIDATION: Only allowed fields can be modified
          allow update: if isStaff(merchantId, branchId) &&
            // Immutable fields: Cannot change core order data
            request.resource.data.userId == resource.data.userId &&
            request.resource.data.merchantId == resource.data.merchantId &&
            request.resource.data.branchId == resource.data.branchId &&
            request.resource.data.items == resource.data.items &&
            request.resource.data.subtotal == resource.data.subtotal &&
            request.resource.data.createdAt == resource.data.createdAt &&
            request.resource.data.orderNo == resource.data.orderNo &&
            // Staff cannot change notifications (reserved for service account)
            // BACKWARD COMPATIBLE: Old orders may not have notifications field
            (!resource.data.keys().hasAny(['notifications']) || request.resource.data.notifications == resource.data.notifications) &&
            // Immutable: fulfillmentType cannot be changed (if present)
            (!resource.data.keys().hasAny(['fulfillmentType']) || request.resource.data.fulfillmentType == resource.data.fulfillmentType) &&
            // Optional immutable fields (if they exist, they cannot be changed)
            (!resource.data.keys().hasAny(['customerPhone']) || request.resource.data.customerPhone == resource.data.customerPhone) &&
            (!resource.data.keys().hasAny(['customerCarPlate']) || request.resource.data.customerCarPlate == resource.data.customerCarPlate) &&
            (!resource.data.keys().hasAny(['table']) || request.resource.data.table == resource.data.table) &&
            (!resource.data.keys().hasAny(['loyaltyDiscount']) || request.resource.data.loyaltyDiscount == resource.data.loyaltyDiscount) &&
            (!resource.data.keys().hasAny(['loyaltyPointsUsed']) || request.resource.data.loyaltyPointsUsed == resource.data.loyaltyPointsUsed) &&
            (!resource.data.keys().hasAny(['customerAddress']) || request.resource.data.customerAddress == resource.data.customerAddress) &&
            // Status field: Must be valid order status
            request.resource.data.status in ['pending', 'accepted', 'preparing', 'ready', 'served', 'cancelled'] &&
            // Valid status transitions (prevent invalid workflows)
            (
              // pending -> accepted, preparing, or cancelled
              (resource.data.status == 'pending' && request.resource.data.status in ['accepted', 'preparing', 'cancelled']) ||
              // accepted -> preparing or cancelled
              (resource.data.status == 'accepted' && request.resource.data.status in ['preparing', 'cancelled']) ||
              // preparing -> ready or cancelled
              (resource.data.status == 'preparing' && request.resource.data.status in ['ready', 'cancelled']) ||
              // ready -> served or cancelled
              (resource.data.status == 'ready' && request.resource.data.status in ['served', 'cancelled']) ||
              // served/cancelled are terminal states (no changes allowed)
              (resource.data.status in ['served', 'cancelled'] && request.resource.data.status == resource.data.status)
            ) &&
            // Audit logging: Must include updatedByUid when status changes
            (request.resource.data.status == resource.data.status ||
             (request.resource.data.updatedByUid is string && request.resource.data.updatedByUid == request.auth.uid)) &&
            // Audit logging: updatedByRole must be valid if present
            (!request.resource.data.keys().hasAny(['updatedByRole']) ||
             request.resource.data.updatedByRole in ['admin', 'staff']) &&
            // Audit logging: updatedByEmail is optional
            (!request.resource.data.keys().hasAny(['updatedByEmail']) ||
             request.resource.data.updatedByEmail is string) &&
            // Status-specific timestamps (optional, set by code)
            (!request.resource.data.keys().hasAny(['preparingAt']) || request.resource.data.preparingAt is timestamp) &&
            (!request.resource.data.keys().hasAny(['readyAt']) || request.resource.data.readyAt is timestamp) &&
            (!request.resource.data.keys().hasAny(['servedAt']) || request.resource.data.servedAt is timestamp) &&
            (!request.resource.data.keys().hasAny(['cancelledAt']) || request.resource.data.cancelledAt is timestamp) &&
            // Cancellation reason: Only when status is cancelled
            (!request.resource.data.keys().hasAny(['cancellationReason']) ||
             request.resource.data.status == 'cancelled') &&
            // updatedAt is always required for updates
            request.resource.data.updatedAt is timestamp;

          // No deletes (preserve order history)
          allow delete: if false;
        }

        // -------------------- ROLES --------------------
        match /roles/{userId} {
          // Individual document read: Staff can read their own, admins can read any
          allow get: if isSignedIn() &&
            (request.auth.uid == userId || isAdmin(merchantId, branchId));

          // Collection queries: Only admins can list all roles
          allow list: if isAdmin(merchantId, branchId);

          // Only admins can manage roles
          allow write: if isAdmin(merchantId, branchId);
        }

        // -------------------- CONFIG (BRANDING & LOYALTY & CHECKOUT FIELDS) --------------------
        // Keep branding/loyalty/checkoutFields public, BUT block public access to notifications config doc.
        match /config/{docId} {
          allow read: if docId != 'notifications';
          allow write: if isAdmin(merchantId, branchId);
        }

        // -------------------- CONFIG (WHATSAPP NOTIFICATIONS) --------------------
        match /config/notifications {
          // STAFF READ: Only staff can see WhatsApp notification config
          allow read: if isStaff(merchantId, branchId);

          // ADMIN CREATE/UPDATE: Only admins can configure WhatsApp notifications
          allow create, update: if isAdmin(merchantId, branchId) &&
            // whatsappEnabled must be boolean
            request.resource.data.whatsappEnabled is bool &&
            // If enabled, whatsappNumber must be valid E.164 format
            (!request.resource.data.whatsappEnabled ||
             (request.resource.data.whatsappNumber is string &&
              request.resource.data.whatsappNumber.matches('^\\+[1-9]\\d{7,14}$'))) &&
            // Audit fields required
            request.resource.data.updatedAt == request.time &&
            request.resource.data.updatedBy == request.auth.uid;

          // No deletes (preserve notification history)
          allow delete: if false;
        }

        // -------------------- CUSTOMERS (LOYALTY) --------------------
        match /customers/{phone} {
          // READ: Anyone signed in can read customer profiles (for points display)
          allow read: if isSignedIn();

          // CREATE: Allow creating customer profiles during checkout
          // carPlate is optional (only for car pickup orders)
          allow create: if isSignedIn() &&
            request.resource.data.phone == phone &&
            // carPlate is optional, but if present must be valid
            (!request.resource.data.keys().hasAny(['carPlate']) ||
             (request.resource.data.carPlate is string && request.resource.data.carPlate.size() > 0)) &&
            request.resource.data.points is int &&
            request.resource.data.points >= 0 &&
            request.resource.data.totalSpent is number &&
            request.resource.data.totalSpent >= 0 &&
            request.resource.data.orderCount is int &&
            request.resource.data.orderCount >= 0 &&
            // lastOrderAt is optional
            (!request.resource.data.keys().hasAny(['lastOrderAt']) || request.resource.data.lastOrderAt is timestamp || request.resource.data.lastOrderAt == null);

          // UPDATE: Allow updating customer profiles (points, spending, etc.)
          allow update: if isSignedIn() &&
            request.resource.data.phone == resource.data.phone &&  // Can't change phone
            // carPlate is optional, but if present must be valid
            (!request.resource.data.keys().hasAny(['carPlate']) ||
             (request.resource.data.carPlate is string && request.resource.data.carPlate.size() > 0)) &&
            request.resource.data.points is int &&
            request.resource.data.points >= 0 &&
            request.resource.data.totalSpent is number &&
            request.resource.data.totalSpent >= resource.data.totalSpent &&  // Can't decrease
            request.resource.data.orderCount is int &&
            request.resource.data.orderCount >= resource.data.orderCount &&  // Can't decrease
            // lastOrderAt is optional
            (!request.resource.data.keys().hasAny(['lastOrderAt']) || request.resource.data.lastOrderAt is timestamp || request.resource.data.lastOrderAt == null);

          // No deletes
          allow delete: if false;
        }

        // -------------------- POINTS TRANSACTIONS (AUDIT TRAIL) --------------------
        match /pointsTransactions/{transactionId} {
          // READ: Staff can view all transactions
          allow read: if isStaff(merchantId, branchId);

          // CREATE: Allow system writes for audit trail
          allow create: if isSignedIn() &&
            request.resource.data.phone is string &&
            request.resource.data.type in ['earned', 'redeemed'] &&
            request.resource.data.points is int;

          // No updates or deletes (immutable audit log)
          allow update, delete: if false;
        }

        // -------------------- COUNTERS (ORDER NUMBERING) --------------------
        match /counters/{counterId} {
          // READ: Anyone signed in can read counters
          allow read: if isSignedIn();

          // WRITE: Anyone signed in can update counters (for order number generation)
          allow write: if isSignedIn();
        }
      }
    }

    // ==================== DENY ALL OTHERS ====================
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
