rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ==================== HELPER FUNCTIONS ====================

    function isSignedIn() {
      return request.auth != null;
    }

    function getUserRole(merchantId, branchId) {
      return isSignedIn() &&
        exists(/databases/$(database)/documents/merchants/$(merchantId)/branches/$(branchId)/roles/$(request.auth.uid))
          ? get(/databases/$(database)/documents/merchants/$(merchantId)/branches/$(branchId)/roles/$(request.auth.uid)).data.role
          : null;
    }

    function isAdmin(merchantId, branchId) {
      return getUserRole(merchantId, branchId) == 'admin';
    }

    function isStaff(merchantId, branchId) {
      return getUserRole(merchantId, branchId) in ['admin', 'staff'];
    }

    // Legacy compatibility
    function isOwner(merchantId, branchId) {
      return isAdmin(merchantId, branchId);
    }

    // Service account check (for Cloudflare Worker)
    function isServiceAccount() {
      return request.auth != null &&
        request.auth.token.email != null &&
        request.auth.token.email.matches('.*@.*\\.iam\\.gserviceaccount\\.com$');
    }

    // Get checkout fields config for validation
    function getCheckoutConfig(merchantId, branchId) {
      let configPath = /databases/$(database)/documents/merchants/$(merchantId)/branches/$(branchId)/config/checkoutFields;
      return exists(configPath) ? get(configPath).data : {
        'phoneRequired': true,
        'plateNumberRequired': true,
        'tableRequired': false,
        'addressRequired': false
      };
    }

    // Validate required checkout fields based on fulfillmentType
    function hasRequiredCheckoutFields(merchantId, branchId, orderData) {
      // fulfillmentType is REQUIRED for all new orders
      let hasFulfillmentType = orderData.keys().hasAny(['fulfillmentType']) &&
        orderData.fulfillmentType is string &&
        orderData.fulfillmentType in ['car_pickup', 'delivery', 'dine_in'];

      // Validate type-specific required fields
      let hasTypeSpecificFields =
        // Car pickup requires customerCarPlate
        (orderData.fulfillmentType == 'car_pickup' &&
         orderData.keys().hasAny(['customerCarPlate']) &&
         orderData.customerCarPlate is string &&
         orderData.customerCarPlate.size() > 0) ||
        // Delivery requires customerAddress with required fields
        (orderData.fulfillmentType == 'delivery' &&
         orderData.keys().hasAny(['customerAddress']) &&
         orderData.customerAddress is map &&
         orderData.customerAddress.keys().hasAny(['home', 'road', 'block', 'city']) &&
         orderData.customerAddress.home is string && orderData.customerAddress.home.size() > 0 &&
         orderData.customerAddress.road is string && orderData.customerAddress.road.size() > 0 &&
         orderData.customerAddress.block is string && orderData.customerAddress.block.size() > 0 &&
         orderData.customerAddress.city is string && orderData.customerAddress.city.size() > 0) ||
        // Dine-in requires table
        (orderData.fulfillmentType == 'dine_in' &&
         orderData.keys().hasAny(['table']) &&
         orderData.table is string &&
         orderData.table.size() > 0);

      return hasFulfillmentType && hasTypeSpecificFields;
    }

    // ==================== GLOBAL COLLECTIONS ====================

    // Slugs: Public read, no direct writes (only via Cloud Functions or manual admin)
    match /slugs/{slug} {
      allow read: if true;
      allow create, update: if isSignedIn();  // Allow for branding_admin_page.dart
      allow delete: if false;  // Prevent accidental deletion
    }

    // ==================== MERCHANT HIERARCHY ====================

    match /merchants/{merchantId} {
      // Merchant doc itself
      allow read: if true;
      allow write: if isOwner(merchantId, 'any');  // At least one branch owner

      match /branches/{branchId} {
        // Branch doc
        allow read: if true;
        allow write: if isStaff(merchantId, branchId);

        // -------------------- MENU ITEMS --------------------
        match /menuItems/{itemId} {
          // PUBLIC READ: Anyone can see menu items (app filters by isActive on client side)
          allow read: if true;

          // ADMIN WRITE: Only admins can create/update/delete menu items
          allow create: if isAdmin(merchantId, branchId) &&
            request.resource.data.merchantId == merchantId &&
            request.resource.data.branchId == branchId &&
            request.resource.data.isActive is bool &&
            request.resource.data.price is number &&
            request.resource.data.price >= 0 &&
            request.resource.data.name is string &&
            request.resource.data.name.size() > 0;

          allow update: if isAdmin(merchantId, branchId);
          allow delete: if isAdmin(merchantId, branchId);
        }

        // -------------------- CATEGORIES --------------------
        match /categories/{categoryId} {
          // PUBLIC READ: Anyone can see categories
          allow read: if true;

          // ADMIN WRITE: Only admins can create/update/delete categories
          allow create, update, delete: if isAdmin(merchantId, branchId);
        }

        // -------------------- ORDERS --------------------
        match /orders/{orderId} {
          // CREATE: Any signed-in user can place order
          // Backwards compatible: notifications is OPTIONAL.
          // If notifications exists, it must be correctly initialized.
          allow create: if isSignedIn() &&
            request.resource.data.userId == request.auth.uid &&
            request.resource.data.status == 'pending' &&
            request.resource.data.merchantId == merchantId &&
            request.resource.data.branchId == branchId &&
            request.resource.data.items is list &&
            request.resource.data.items.size() > 0 &&
            request.resource.data.items.size() <= 50 &&
            request.resource.data.subtotal is number &&
            request.resource.data.subtotal >= 0 &&
            request.resource.data.subtotal <= 1000 &&
            (
              !request.resource.data.keys().hasAny(['notifications']) ||
              (
                request.resource.data.notifications is map &&
                request.resource.data.notifications.keys().hasOnly(['waNewSent', 'waCancelSent']) &&
                request.resource.data.notifications.waNewSent == false &&
                request.resource.data.notifications.waCancelSent == false
              )
            ) &&
            hasRequiredCheckoutFields(merchantId, branchId, request.resource.data);

          // READ: Own orders or staff
          allow read: if isSignedIn() &&
            (resource.data.userId == request.auth.uid ||
             isStaff(merchantId, branchId));

          // UPDATE: Service account (Cloudflare Worker) can ONLY update notification fields
          allow update: if isServiceAccount() &&
            request.resource.data.diff(resource.data).affectedKeys().hasOnly(['notifications']) &&
            request.resource.data.notifications is map &&
            request.resource.data.notifications.keys().hasOnly([
              'waNewSent', 'waCancelSent',
              'waNewSentAt', 'waNewSid',
              'waCancelSentAt', 'waCancelSid'
            ]);

          // UPDATE: Staff (including admin) can ONLY update order status workflow fields
          // STRICT VALIDATION: Only allowed fields can be modified (using affectedKeys)
          allow update: if isStaff(merchantId, branchId) &&
            request.resource.data.diff(resource.data).affectedKeys().hasOnly([
              'status',
              'updatedAt',
              'updatedByUid',
              'updatedByRole',
              'updatedByEmail',
              'acceptedAt',          // ✅ FIX: allow accept timestamp
              'preparingAt',
              'readyAt',
              'servedAt',
              'cancelledAt',
              'cancellationReason'
            ]) &&
            request.resource.data.status in ['pending', 'accepted', 'preparing', 'ready', 'served', 'cancelled'] &&
            (
              (resource.data.status == 'pending' && request.resource.data.status in ['accepted', 'preparing', 'cancelled']) ||
              (resource.data.status == 'accepted' && request.resource.data.status in ['preparing', 'cancelled']) ||
              (resource.data.status == 'preparing' && request.resource.data.status in ['ready', 'cancelled']) ||
              (resource.data.status == 'ready' && request.resource.data.status in ['served', 'cancelled']) ||
              (resource.data.status in ['served', 'cancelled'] && request.resource.data.status == resource.data.status)
            ) &&
            // ✅ FIX: acceptedAt can ONLY be set when status becomes accepted
            (
              !request.resource.data.diff(resource.data).affectedKeys().hasAny(['acceptedAt']) ||
              (
                request.resource.data.status == 'accepted' &&
                request.resource.data.acceptedAt is timestamp
              )
            ) &&
            (request.resource.data.status == resource.data.status ||
             (request.resource.data.updatedByUid is string && request.resource.data.updatedByUid == request.auth.uid)) &&
            request.resource.data.updatedAt is timestamp;

          allow delete: if false;
        }

        // -------------------- ROLES --------------------
        match /roles/{userId} {
          allow get: if isSignedIn() &&
            (request.auth.uid == userId || isAdmin(merchantId, branchId));

          allow list: if isAdmin(merchantId, branchId);

          allow write: if isAdmin(merchantId, branchId);
        }

        // -------------------- CONFIG (BRANDING & LOYALTY & CHECKOUT FIELDS) --------------------
        match /config/{docId} {
          allow read: if docId != 'notifications';
          allow write: if isAdmin(merchantId, branchId);
        }

        // -------------------- CONFIG (WHATSAPP NOTIFICATIONS) --------------------
        match /config/notifications {
          allow read: if isStaff(merchantId, branchId);

          allow create, update: if isAdmin(merchantId, branchId) &&
            request.resource.data.whatsappEnabled is bool &&
            (!request.resource.data.whatsappEnabled ||
             (request.resource.data.whatsappNumber is string &&
              request.resource.data.whatsappNumber.matches('^\\+[1-9]\\d{7,14}$'))) &&
            request.resource.data.updatedAt == request.time &&
            request.resource.data.updatedBy == request.auth.uid;

          allow delete: if false;
        }

        // -------------------- CUSTOMERS (LOYALTY) --------------------
        match /customers/{phone} {
          allow read: if isSignedIn();

          allow create: if isSignedIn() &&
            request.resource.data.phone == phone &&
            (!request.resource.data.keys().hasAny(['carPlate']) ||
             (request.resource.data.carPlate is string && request.resource.data.carPlate.size() > 0)) &&
            request.resource.data.points is int &&
            request.resource.data.points >= 0 &&
            request.resource.data.totalSpent is number &&
            request.resource.data.totalSpent >= 0 &&
            request.resource.data.orderCount is int &&
            request.resource.data.orderCount >= 0 &&
            (!request.resource.data.keys().hasAny(['lastOrderAt']) || request.resource.data.lastOrderAt is timestamp || request.resource.data.lastOrderAt == null);

          allow update: if isSignedIn() &&
            request.resource.data.phone == resource.data.phone &&
            (!request.resource.data.keys().hasAny(['carPlate']) ||
             (request.resource.data.carPlate is string && request.resource.data.carPlate.size() > 0)) &&
            request.resource.data.points is int &&
            request.resource.data.points >= 0 &&
            request.resource.data.totalSpent is number &&
            request.resource.data.totalSpent >= resource.data.totalSpent &&
            request.resource.data.orderCount is int &&
            request.resource.data.orderCount >= resource.data.orderCount &&
            (!request.resource.data.keys().hasAny(['lastOrderAt']) || request.resource.data.lastOrderAt is timestamp || request.resource.data.lastOrderAt == null);

          allow delete: if false;
        }

        // -------------------- POINTS TRANSACTIONS (AUDIT TRAIL) --------------------
        match /pointsTransactions/{transactionId} {
          allow read: if isStaff(merchantId, branchId);

          allow create: if isSignedIn() &&
            request.resource.data.phone is string &&
            request.resource.data.type in ['earned', 'redeemed'] &&
            request.resource.data.points is int;

          allow update, delete: if false;
        }

        // -------------------- COUNTERS (ORDER NUMBERING) --------------------
        match /counters/{counterId} {
          allow read: if isSignedIn();
          allow write: if isSignedIn();
        }
      }
    }

    // ==================== DENY ALL OTHERS ====================
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
